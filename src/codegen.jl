##codegen.jl
# functions relating to verilog code generation and verilation.

function normalized_key(mod::Union{Function, Symbol}, p::Tuple)
  m_rep = Symbol(mod)

  for k in keys(__global_dependency_cache)
    if (k[1] == Symbol(mod)) && ([p...] == [pair.second for pair in k[2:end]])
      return k
    end
  end

  throw(ArgumentError("Key not found!"))
end

doc"""
  `Verilog.find_dependencies(mod, (params...))`

  outputs the set of dependencies of a certain module.
"""
@generated function find_dependencies(mod, p::Tuple, exclude = [])
  if mod <: Function  #then it's a "manual call"
    tuplegen = :(key = normalized_key(mod, p))
  elseif mod == Symbol
    tuplegen = :(key = (mod, p...))
  else
    throw(ArgumentError("module type unsupported: $mod"))
  end

  quote
    $tuplegen
    deps = __global_dependency_cache[key]

    result = Tuple[]
    #now iterate through the dependencies.

    for d in deps
      if !((d in result) || (d in exclude))
        pushfirst!(result, d)
        result = union(result, find_dependencies(d[1], d[2:end]))
      end
    end
    result
  end
end

const lintoff_stmts = """
/* verilator lint_off DECLFILENAME */
/* verilator lint_off UNUSED */
/* verilator lint_off PINMISSING */

"""

doc"""
  `generate_verilog_file(path, mod, (params...); exclude = [])`

  pass this function a path, (verilog module) name and the parameters, and it
  puts that module and its dependencies into a file in the desired path.  The
  filename will be (module name + suffix).v, with module name & suffix as
  generated by the interal specifications.
"""
function generate_verilog_file(path::String, mod::Function, p::Tuple; exclude = [])
  #test to see if the path exists.
  isdir(path) || mkdir(path)
  #first call the function and make it.
  modulestring = mod(p...)
  modulename = ""

  #next call its dependencies.
  deps = find_dependencies(mod, p, exclude)
  depstrings = [__global_definition_cache[dep].txt for dep in deps]

  #next, retrieve the proper name for the file.
  nkey = normalized_key(mod, p)

  modulename = __global_definition_cache[nkey].module_name

  #next, create a file for the header.
  vfile_fio = open(string(path, "/", modulename, ".v"), "w")
  try
    #write the contents
    println(vfile_fio, lintoff_stmts)
    println(vfile_fio, join(depstrings, "\n\n"))
    println(vfile_fio, modulestring)
  finally
    #close the directory
    close(vfile_fio)
  end

  #return its dependencies so that we can keep track of all modules we've
  #created so far.
  pushfirst!(deps, nkey)
  deps
end

export generate_verilog_file

doc"""
  `verilate(mod::Function, p::Tuple)`
  uses verilator to create a .so file corresponding to the library.
  Each of the functions in the mods array will be the top-level element
  in a freestanding .v file.  They may refer to each other.
  the "mods" are a tuple of the function and the parameter.

  Passed options:
    path::String      - defaults to "." - the library .so file will be placed in the path.
    libname::String   - file name for the library.  Defaults to libVerilated-[function_with_suffix].so
    with_source::Bool - defaults to "false" - should the c source be included?
                        this is useful if you're building a library around the
                        verilated module.
"""
function verilate(mod::Function, p::Tuple; path::String = ".", libname::String="", with_source = false)
  #check to see if the path_to_c_library is actually a dir.
  isdir(path) || mkdir(path)

  nkey = normalized_key(mod, p)
  #retrieve the proper name of this function
  name = __global_definition_cache[nkey].module_name

  if libname == ""
    libname = "libVerilated-$(name).so"
  end

  println("verilating to generate $path/$libname")

  #create the temp directory
  mktempdir((tdir)->begin
    #create the interface cpp file.
    open((file) -> begin
      println(file, verilator_adapter(nkey))
    end, string(tdir, "/", name, "_interface.cpp"), "w")

    println("tdir:", tdir)
    generate_verilog_file(tdir, mod, p)

    #next move into the temporary directory and then
    cd(()->begin
      run(`verilator -Wall --cc -CFLAGS -fPIC $name.v --top-module $name --exe $(name)_interface.cpp`)
    end, tdir)

    cd(()-> begin
      #run the make file.  This will throw an error due to not finding a --main
      #but that's OK it just needs to make the object files.
      run(`make -f V$name.mk`)

      object_files = ["$tdir/obj_dir/$f" for f in readdir() if f[end-1:end] == ".o"]

      #manually link the object files into a shared library.
      run(`cc -Wall -shared $object_files -o $libname`)
    end, "$tdir/obj_dir")

    #in the case that the caller requests the source code
    if (with_source)
      #copy all the source files to the destination directory
      cp("$tdir/", "$path/"; remove_destination=true)
    else
      #finally, save the temporary verilated file into the main path, squashing it if necessary.
      mv("$tdir/obj_dir/$libname", "$path/$libname"; remove_destination=true)
    end
  end)
end

doc"""
  `@verilate function parameters [path]`

  verilates a @verilog function with the passed parameter and places the shared
  object library into [path].  By default, the path used is going to be
  "./libVerilated-[function].so".

  the function is then hooked up to a function with signature []
"""
macro verilate(f, p = (), path...)
  #f should be a symbol
  @assert isa(f, Symbol) "@verilate must be run on a function symbol"
  #check to make sure that f is in the function database.

  @assert isa(eval(Main, f), Function) "@verilate must be run on a function symbol"

  if length(path) == 1
    path = path[1]
    @assert isa(path, String) "@verilate paths must be strings"
  else
    path = "./libVerilated-$f.so"
  end

  (dir, fname) = splitdir(path)
  realdir = realpath(dir)

  #trigger compilation of the function verilog by executing the parameter tuple
  #on a blank version of the function.
  v_fn = eval(Main, f)
  v_p  = eval(Main, p)
  v_fn(v_p...)

  #assign the module cache
  mod_cache = Verilog.__global_definition_cache[normalized_key(f, v_p)]
  name = mod_cache.module_name

  #generate the input tuple and input signature
  input_signature = :(())
  input_converts = :()
  input_ccall = :(ccall((:set, $path), Void, $input_signature))
  for idx = 1:length(mod_cache.inputs)
    iname = Symbol(:input, idx)
    input_converts = :($input_converts; $iname = UInt64($iname))
    push!(input_signature.args, :UInt64)
    push!(input_ccall.args, iname)
  end

  #create "c" versions of the function
  cfunctionname = Symbol(name, "_c")

  #build the output type object to be consistent with the c definition.
  #also build the return tuple command.
  otypename = Symbol("__", name, "_output_type")
  output_type_generator = :(type $otypename; end)
  return_tuple = :(())
  create_tuple = :(())
  for idx = 1:length(mod_cache.outputlist)
    oname = Symbol(:output, idx)
    push!(output_type_generator.args[3].args, :($oname::UInt64))
    push!(return_tuple.args, :(output_ref.$oname))
    push!(create_tuple.args, 0x0000_0000_0000_0000)
  end

  #generate the code for the evaluation function
  if length(mod_cache.outputlist) == 1
    efunc = :(function ($cfunctionname)()
      #create an output_ref
      $input_ccall
      ccall((:step, $path), Void, ())
      res = ccall((:get, $path), UInt64, ())
      res
    end)
  else
    efunc = :(function ($cfunctionname)()
      #create an output_ref
      output_ref = $otypename(($create_tuple)...)
      $input_ccall
      ccall((:step, $path), Void, ())
      ccall((:get, $path), Void, (Ptr{$otypename},), pointer_from_objref(output_ref))
      $return_tuple
    end)
  end

  #append input definitions onto the efunc.
  for idx = 1:length(mod_cache.inputs)
    input_name = Symbol(:input, idx)
    input_stmt = :($input_name::Unsigned)
    push!(efunc.args[1].args, input_stmt)
  end

  #this needs to be eval'd because julia is finicky.
  eval(Main, output_type_generator)

  #this also needs to be eval'd because of the way that julia
  #parses and executes ccalls.
  eval(Main, :(verilate($f, $p, path = $realdir, libname = $fname)))

  esc(quote
    #initialize the verilated version of the function.
    ccall((:init, $path), Void, ())

    $efunc
  end)
end

export verilate
export @verilate
